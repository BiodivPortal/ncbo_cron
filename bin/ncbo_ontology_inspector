#!/usr/bin/env ruby

# Exit cleanly from an early interrupt
Signal.trap("INT") { exit 1 }

# Setup the bundled gems in our environment
require 'bundler/setup'

# Configure the process for the current cron configuration.
require_relative '../lib/ncbo_cron'
config_exists = File.exist?(File.expand_path('../../config/config.rb', __FILE__))
abort("Please create a config/config.rb file using the config/config.rb.sample as a template") unless config_exists
require_relative '../config/config';

#platform = "local"
#if LinkedData.settings.goo_host.include? "stage"
#  platform = "stage"
#elsif LinkedData.settings.goo_host.include? "prod"
#  platform = "prod"
#end

require 'optparse'
options = {}
opt_parser = OptionParser.new do |opts|
  # Set a banner, displayed at the top of the help screen.
  #opts.banner = "Usage: ncbo_ontology_index [options]"
  opts.on('-o', '--ontologies ACRONYM[,ACRONYM,...]', 'Ontology acronym to inspect (default: all ontologies).') do |acronym|
    options[:ontologies] = acronym.split(',')
  end
  opts.on('-p', '--properties PROPERTY[,PROPERTY,...]', 'Ontology properties to inspect (REST API properties)') do |properties|
    properties.split(',').each {|property| options[property.to_sym] = true }
  end
  # Display the help screen, all programs are assumed to have this option.
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end
# Parse the command-line. The 'parse' method simply parses ARGV, while the 'parse!' method parses ARGV and removes
# any options found there, as well as any parameters for the options.
opt_parser.parse!
unless options[:ontologies]
  onts = LinkedData::Models::Ontology.all
  options[:ontologies] = onts.map {|o| o.bring(:acronym) && o.acronym }
end


def ont_status(sub, sep)
  # Summarise the submission status
end


#
# MAIN
#
options[:ontologies].each do |acronym|
  begin
    ont = LinkedData::Models::Ontology.find(acronym).first
    if ont.nil?
      # TODO: might have to add padding for 'cuttable' output.
      puts "#{acronym}; ontology not found"
    end
    ont.bring_remaining
    # Create one-line output - compatible with unix string processing tools.
    sep = ';; '

    # This section can inspect common properties of ontologies, including summaryOnly ontologies.
    puts "#{ont.acronym}#{sep}"
    puts "id = #{ont.id}#{sep}" if options[:id]
    puts "acronym = #{ont.acronym}#{sep}" if options[:acronym]
    puts "name = #{ont.name}#{sep}" if options[:name]
    puts "viewingRestriction = #{ont.viewingRestriction}#{sep}" if options[:viewingRestriction]

    #@acl=[],
    binding.pry if options[:acl]

    binding.pry if options[:administeredBy]
    #@administeredBy=
    #    [#<LinkedData::Models::User:0x007f319a24c7a0
    #        @aggregates=nil,
    #        @id=
    #            #<RDF::URI:0x3f98cd3f168c(http://data.bioontology.org/users/maskot1977)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    puts "doNotUpdate = #{ont.doNotUpdate}#{sep}" if options[:doNotUpdate]
    puts "flat = #{ont.flat}#{sep}" if options[:flat]
    puts "group = #{ont.group.to_json}#{sep}" if options[:group]
    puts "hasDomain = #{ont.hasDomain}#{sep}" if options[:hasDomain]
    puts "viewOf = #{ont.viewOf}#{sep}" if options[:viewOf]
    puts "summaryOnly = #{ont.summaryOnly}#{sep}" if options[:summaryOnly]
    #@aggregates=nil,  # don't know what to do with this.
    # summaryOnly ontologies cannot be inspected any further.
    next if ont.summaryOnly


    binding.pry

    # Proceed to get additional properties from the latest submission
    sub = ont.latest_submission(status: :any)
    if sub.nil?
      puts "#{acronym}, no latest submission."
      next
    end
    sub.bring_remaining


    ont_status(sub, sep) if options[:status]


    hasOntologyLanguage = sub.hasOntologyLanguage.id.to_s.split('/').last
    puts "hasOntologyLanguage = #{hasOntologyLanguage}#{sep}" if options[:hasOntologyLanguage]

  rescue Exception => e
    puts "Failed, exception: #{e.to_json}."
  end
end

