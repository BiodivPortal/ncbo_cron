#!/usr/bin/env ruby

# Exit cleanly from an early interrupt
Signal.trap("INT") { exit 1 }

# Setup the bundled gems in our environment
require 'bundler/setup'

# Configure the process for the current cron configuration.
require_relative '../lib/ncbo_cron'
config_exists = File.exist?(File.expand_path('../../config/config.rb', __FILE__))
abort("Please create a config/config.rb file using the config/config.rb.sample as a template") unless config_exists
require_relative '../config/config';

#platform = "local"
#if LinkedData.settings.goo_host.include? "stage"
#  platform = "stage"
#elsif LinkedData.settings.goo_host.include? "prod"
#  platform = "prod"
#end

require 'optparse'
options = {}
opt_parser = OptionParser.new do |opts|
  # Set a banner, displayed at the top of the help screen.
  #opts.banner = "Usage: ncbo_ontology_index [options]"
  opts.on('-o', '--ontologies ACRONYM[,ACRONYM,...]', 'Ontology acronym to inspect (default: all ontologies).') do |acronym|
    options[:ontologies] = acronym.split(',')
  end
  opts.on('-p', '--properties PROPERTY[,PROPERTY,...]', 'Ontology properties to inspect (REST API properties)') do |properties|
    options[:properties] = {}
    properties.split(',').each {|property| options[:properties][property.to_sym] = true }
  end
  # Display the help screen, all programs are assumed to have this option.
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end
# Parse the command-line. The 'parse' method simply parses ARGV, while the 'parse!' method parses ARGV and removes
# any options found there, as well as any parameters for the options.
opt_parser.parse!
unless options[:properties]
  # Don't assume anything, ask for properties explicitly.
  puts opt_parser.help
  exit(1)
end
unless options[:ontologies]
  onts = LinkedData::Models::Ontology.all
  options[:ontologies] = onts.map {|o| o.bring(:acronym) && o.acronym }
end

#
# functions for complex values
#
def submission_status(sub)
  # TODO: summarise the submission status
  binding.pry
end

def submission_hasOntologyLanguage(sub)
  sub.hasOntologyLanguage.id.to_s.split('/').last
end



SEPARATOR = ';; '
def print_element(name, value)
  # TODO: modify value when it's a complex object, like Array, Hash, etc.
  print "#{name} = #{value}#{SEPARATOR}"
  STDOUT.flush
end


#
# MAIN
#
exit(1) if options[:properties].empty?  # nothing to be done

options[:ontologies].each do |acronym|
  properties = options[:properties].clone  # clone, so properties can be modified
  begin
    # Create one-line output - compatible with unix string processing tools.
    print_element('acronym', acronym)  # always output the acronym
    properties.delete(:acronym) && next if properties.empty?  # try to be efficient

    # Inspect additional ontology properties
    ont = LinkedData::Models::Ontology.find(acronym).first
    if ont.nil?
      print_element('ontology', 'ERROR')
      next
    else
      print_element('ontology', 'found')
    end
    ont.bring_remaining

    # A generic solution is possible, but I want more control over things ;-)
    #properties.keys.sort.each do |property|
    #  if ont.respond_to? property
    #    value = ont.method(property).call
    #    print_element(property, value)
    #  end
    #end
    #

    # This section can inspect common properties of ontologies, including summaryOnly ontologies.
    if properties[:id]
      print_element('id', ont.id.to_s)
      properties.delete(:id) && next if properties.empty?  # try to be efficient
    end
    if properties[:name]
      print_element('name', ont.name)
      properties.delete(:name) && next if properties.empty?  # try to be efficient
    end
    if properties[:viewingRestriction]
      print_element('viewingRestriction', ont.viewingRestriction)
      properties.delete(:viewingRestriction) && next if properties.empty?  # try to be efficient
    end

    if properties[:acl]
      # TODO: check how to display acl
      binding.pry

      print_element('acl', ont.acl)
      properties.delete(:acl) && next if properties.empty?  # try to be efficient
    end

    if properties[:administeredBy]
      # TODO: check how to display administeredBy
      binding.pry

      print_element('administeredBy', ont.administeredBy)
      properties.delete(:administeredBy) && next if properties.empty?  # try to be efficient
    end
    #@administeredBy=
    #    [#<LinkedData::Models::User:0x007f1bfeafbf60
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff54d2d4(http://data.bioontology.org/users/rubin)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>,
    #        #<LinkedData::Models::User:0x007f1bfeb1e2e0
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff557428(http://data.bioontology.org/users/paul)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    if properties[:group]
      # TODO: check how to display group
      binding.pry

      print_element('group', ont.group)
      properties.delete(:group) && next if properties.empty?  # try to be efficient
    end
    #@group=
    #    [#<LinkedData::Models::Group:0x007f1bfeafb010
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff54d158(http://data.bioontology.org/groups/CTSA)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    print_element('hasDomain', ont.hasDomain) if properties[:hasDomain]
    #@hasDomain=
    #    [#<LinkedData::Models::Category:0x007f1bfeaf9288
    #        @aggregates=nil,
    #        @id=
    #            #<RDF::URI:0x3f8dff551528(http://data.bioontology.org/categories/Biomedical_Resources)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>,
    #        #<LinkedData::Models::Category:0x007f1bfeb105c8
    #        @aggregates=nil,
    #        @id=
    #            #<RDF::URI:0x3f8dff557c34(http://data.bioontology.org/categories/Other)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    if properties[:viewOf]
      # TODO: check that viewOf output is OK
      binding.pry

      print_element('viewOf', ont.viewOf)
      properties.delete(:viewOf) && next if properties.empty?  # try to be efficient
    end
    if properties[:flat]
      print_element('flat', ont.flat)
      properties.delete(:flat) && next if properties.empty?  # try to be efficient
    end
    if properties[:doNotUpdate]
      print_element('doNotUpdate', ont.doNotUpdate)
      properties.delete(:doNotUpdate)
      next if properties.empty?  # try to be efficient
    end
    if properties[:summaryOnly]
      print_element('summaryOnly', ont.summaryOnly)
      properties.delete(:summaryOnly) && next if properties.empty?  # try to be efficient
    end
    #
    # don't want to inspect these goo properties
    #@aggregates=nil,
    #@persistent=true,
    #@previous_values=nil,
    #@unmapped=nil,
    #
    # summaryOnly ontologies cannot be inspected any further.
    if ont.summaryOnly
      print_element('submission', 'NONE, summaryOnly')
      next
    end
    # Proceed to get additional properties from the latest submission
    sub = ont.latest_submission(status: :any)
    if sub.nil?
      print_element('submission', 'ERROR')
      next
    else
      print_element('submission', 'found')
    end
    sub.bring_remaining

    # TODO: list all the submission properties to be inspected
    binding.pry
    exit!

    if properties[:status]
      print_element('status', submission_status(sub))
      properties.delete(:status) && next if properties.empty?  # try to be efficient
    end
    if properties[:hasOntologyLanguage]
      print_element('hasOntologyLanguage', submission_hasOntologyLanguage(sub))
      properties.delete(:hasOntologyLanguage) && next if properties.empty?  # try to be efficient
    end


  rescue Exception => e
    puts "Failed, exception: #{e.to_json}."
  end
end

