#!/usr/bin/env ruby

# Exit cleanly from an early interrupt
Signal.trap("INT") { exit 1 }

# Setup the bundled gems in our environment
require 'bundler/setup'

# Configure the process for the current cron configuration.
require_relative '../lib/ncbo_cron'
config_exists = File.exist?(File.expand_path('../../config/config.rb', __FILE__))
abort("Please create a config/config.rb file using the config/config.rb.sample as a template") unless config_exists
require_relative '../config/config';

#platform = "local"
#if LinkedData.settings.goo_host.include? "stage"
#  platform = "stage"
#elsif LinkedData.settings.goo_host.include? "prod"
#  platform = "prod"
#end

require 'optparse'
options = {}
opt_parser = OptionParser.new do |opts|
  # Set a banner, displayed at the top of the help screen.
  #opts.banner = "Usage: ncbo_ontology_index [options]"
  opts.on('-o', '--ontologies ACRONYM[,ACRONYM,...]', 'Ontology acronym to inspect (default: all ontologies).') do |acronym|
    options[:ontologies] = acronym.split(',')
  end
  opts.on('-p', '--properties PROPERTY[,PROPERTY,...]', 'Ontology properties to inspect (REST API properties)') do |properties|
    options[:properties] = {}
    properties.split(',').each {|property| options[:properties][property.to_sym] = true }
  end
  # Display the help screen, all programs are assumed to have this option.
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end
# Parse the command-line. The 'parse' method simply parses ARGV, while the 'parse!' method parses ARGV and removes
# any options found there, as well as any parameters for the options.
opt_parser.parse!
unless options[:properties]
  # Don't assume anything, ask for properties explicitly.
  puts opt_parser.help
  exit(1)
end
unless options[:ontologies]
  onts = LinkedData::Models::Ontology.all
  options[:ontologies] = onts.map {|o| o.bring(:acronym) && o.acronym }
end

#
# functions for complex values
#
def submission_status(sub)
  # TODO: summarise the submission status
  binding.pry
end

def submission_hasOntologyLanguage(sub)
  sub.hasOntologyLanguage.id.to_s.split('/').last
end



SEPARATOR = ';; '
def print_element(name, value)
  # TODO: modify value when it's a complex object, like Array, Hash, etc.
  print "#{name} = #{value}#{SEPARATOR}"
  STDOUT.flush
end


#
# MAIN
#
properties = options[:properties]  # cannot be empty
exit(1) if properties.empty?

options[:ontologies].each do |acronym|
  begin
    # Create one-line output - compatible with unix string processing tools.
    print_element('acronym', acronym)  # always output the acronym
    ont = LinkedData::Models::Ontology.find(acronym).first
    if ont.nil?
      print_element('ontology', 'ERROR')
      next
    end
    ont.bring_remaining

    # A generic solution is possible, but I want more control over things ;-)
    #properties.keys.sort.each do |property|
    #  if ont.respond_to? property
    #    value = ont.method(property).call
    #    print_element(property, value)
    #  end
    #end
    #

    # This section can inspect common properties of ontologies, including summaryOnly ontologies.
    #puts "acronym = #{ont.acronym}#{sep}" if options[:acronym]
    print_element('id', ont.id.to_s) if properties[:id]
    print_element('name', ont.name) if properties[:name]
    print_element('viewingRestriction', ont.viewingRestriction) if properties[:viewingRestriction]

    #@acl=[],
    binding.pry if properties[:acl]

    binding.pry if properties[:administeredBy]
    #@administeredBy=
    #    [#<LinkedData::Models::User:0x007f1bfeafbf60
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff54d2d4(http://data.bioontology.org/users/rubin)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>,
    #        #<LinkedData::Models::User:0x007f1bfeb1e2e0
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff557428(http://data.bioontology.org/users/paul)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    # TODO: check that group output is OK, use group.to_json?
    print_element('group', ont.group) if properties[:group]
    #@group=
    #    [#<LinkedData::Models::Group:0x007f1bfeafb010
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff54d158(http://data.bioontology.org/groups/CTSA)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    print_element('hasDomain', ont.hasDomain) if properties[:hasDomain]
    #@hasDomain=
    #    [#<LinkedData::Models::Category:0x007f1bfeaf9288
    #        @aggregates=nil,
    #        @id=
    #            #<RDF::URI:0x3f8dff551528(http://data.bioontology.org/categories/Biomedical_Resources)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>,
    #        #<LinkedData::Models::Category:0x007f1bfeb105c8
    #        @aggregates=nil,
    #        @id=
    #            #<RDF::URI:0x3f8dff557c34(http://data.bioontology.org/categories/Other)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    # TODO: check that viewOf output is OK
    print_element('viewOf', ont.viewOf) if properties[:viewOf]
    print_element('flat', ont.flat) if properties[:flat]
    print_element('doNotUpdate', ont.doNotUpdate) if properties[:doNotUpdate]
    print_element('summaryOnly', ont.summaryOnly) if properties[:summaryOnly]

    # don't want to inspect these goo properties
    #@aggregates=nil,
    #@persistent=true,
    #@previous_values=nil,
    #@unmapped=nil,

    # summaryOnly ontologies cannot be inspected any further.
    if ont.summaryOnly
      print_element('submission', 'NONE, summaryOnly')
      next
    end

    # Proceed to get additional properties from the latest submission
    sub = ont.latest_submission(status: :any)
    if sub.nil?
      print_element('submission', 'ERROR')
      next
    end
    sub.bring_remaining

    print_element('status', submission_status(sub)) if properties[:status]
    print_element('hasOntologyLanguage', submission_hasOntologyLanguage(sub)) if properties[:hasOntologyLanguage]

    # TODO: list all the submission properties to be inspected
    binding.pry
    exit!


  rescue Exception => e
    puts "Failed, exception: #{e.to_json}."
  end
end

