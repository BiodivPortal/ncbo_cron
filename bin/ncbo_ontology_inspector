#!/usr/bin/env ruby

# Exit cleanly from an early interrupt
Signal.trap("INT") { exit 1 }

# Setup the bundled gems in our environment
require 'bundler/setup'

# Configure the process for the current cron configuration.
require_relative '../lib/ncbo_cron'
config_exists = File.exist?(File.expand_path('../../config/config.rb', __FILE__))
abort("Please create a config/config.rb file using the config/config.rb.sample as a template") unless config_exists
require_relative '../config/config';

#platform = "local"
#if LinkedData.settings.goo_host.include? "stage"
#  platform = "stage"
#elsif LinkedData.settings.goo_host.include? "prod"
#  platform = "prod"
#end

require 'optparse'
options = {}
opt_parser = OptionParser.new do |opts|
  # Set a banner, displayed at the top of the help screen.
  #opts.banner = "Usage: ncbo_ontology_index [options]"
  opts.on('-o', '--ontologies ACRONYM[,ACRONYM,...]', 'Ontology acronym to inspect (default: all ontologies).') do |acronym|
    options[:ontologies] = acronym.split(',')
  end
  opts.on('-p', '--properties PROPERTY[,PROPERTY,...]', 'Ontology properties to inspect (REST API properties)') do |properties|
    options[:properties] = {}
    properties.split(',').each {|property| options[:properties][property.to_sym] = true }
  end
  # Display the help screen, all programs are assumed to have this option.
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end
# Parse the command-line. The 'parse' method simply parses ARGV, while the 'parse!' method parses ARGV and removes
# any options found there, as well as any parameters for the options.
opt_parser.parse!
unless options[:properties]
  # Don't assume anything, ask for properties explicitly.
  puts opt_parser.help
  exit(1)
end
unless options[:ontologies]
  onts = LinkedData::Models::Ontology.all
  options[:ontologies] = onts.map {|o| o.bring(:acronym) && o.acronym }
end

#
# functions for complex values
#
def submission_metrics(sub)
  metrics = sub.metrics
  metrics.bring_remaining
  return "averageChildCount:#{metrics.averageChildCount}," +
      "classes:#{metrics.classes}," +
      "classesWithMoreThan25Children:#{metrics.classesWithMoreThan25Children}," +
      "classesWithNoDefinition:#{metrics.classesWithNoDefinition}," +
      "classesWithOneChild:#{metrics.classesWithOneChild}," +
      "individuals:#{metrics.individuals}," +
      "maxChildCount:#{metrics.maxChildCount}," +
      "maxDepth:#{metrics.maxDepth}," +
      "properties:#{metrics.properties}"
end

def submission_status(sub)
  submission_status = sub.submissionStatus.map {|s| s.id.to_s.split('/').last }
  return submission_status.join(',')
end

def submission_hasOntologyLanguage(sub)
  sub.hasOntologyLanguage.id.to_s.split('/').last
end



SEPARATOR = ';; '
def print_element(name, value)
  # TODO: modify value when it's a complex object, like Array, Hash, etc.
  print "#{name} = #{value}#{SEPARATOR}"
  STDOUT.flush
end


#
# MAIN
#
exit(1) if options[:properties].empty?  # nothing to be done

# NOTE: weird syntax, but this construct below will print "\n" (returns nil) AND then it does next;
#       it does nothing at all for a false if clause (not even the print "\n").
# print "\n" or next if properties.empty?

options[:ontologies].each do |acronym|
  properties = options[:properties].clone  # clone, so properties can be modified
  begin
    # Create one-line output - compatible with unix string processing tools.
    print_element('acronym', acronym)  # always output the acronym
    properties.delete(:acronym)
    print "\n" or next if properties.empty?

    # Inspect additional ontology properties
    ont = LinkedData::Models::Ontology.find(acronym).first
    if ont.nil?
      print_element('ontology', 'ERROR')
      print "\n" or next
    else
      print_element('ontology', 'found')
    end
    ont.bring_remaining

    # A generic solution is possible, but I want more control over things ;-)
    #properties.keys.sort.each do |property|
    #  if ont.respond_to? property
    #    value = ont.method(property).call
    #    print_element(property, value)
    #  end
    #end
    #

    # This section can inspect common properties of ontologies, including summaryOnly ontologies.
    if properties[:id]
      print_element('id', ont.id.to_s)
      properties.delete(:id)
      print "\n" or next if properties.empty?
    end
    if properties[:name]
      print_element('name', ont.name)
      properties.delete(:name)
      print "\n" or next if properties.empty?
    end
    if properties[:viewingRestriction]
      print_element('viewingRestriction', ont.viewingRestriction)
      properties.delete(:viewingRestriction)
      print "\n" or next if properties.empty?
    end

    if properties[:acl]
      # TODO: check how to display acl
      binding.pry

      print_element('acl', ont.acl)
      properties.delete(:acl)
      print "\n" or next if properties.empty?
    end

    if properties[:administeredBy]
      # TODO: check how to display administeredBy
      binding.pry

      print_element('administeredBy', ont.administeredBy)
      properties.delete(:administeredBy)
      print "\n" or next if properties.empty?
    end
    #@administeredBy=
    #    [#<LinkedData::Models::User:0x007f1bfeafbf60
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff54d2d4(http://data.bioontology.org/users/rubin)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>,
    #        #<LinkedData::Models::User:0x007f1bfeb1e2e0
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff557428(http://data.bioontology.org/users/paul)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    if properties[:group]
      # TODO: check how to display group
      binding.pry

      print_element('group', ont.group)
      properties.delete(:group)
      print "\n" or next if properties.empty?
    end
    #@group=
    #    [#<LinkedData::Models::Group:0x007f1bfeafb010
    #        @aggregates=nil,
    #        @id=#<RDF::URI:0x3f8dff54d158(http://data.bioontology.org/groups/CTSA)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    print_element('hasDomain', ont.hasDomain) if properties[:hasDomain]
    #@hasDomain=
    #    [#<LinkedData::Models::Category:0x007f1bfeaf9288
    #        @aggregates=nil,
    #        @id=
    #            #<RDF::URI:0x3f8dff551528(http://data.bioontology.org/categories/Biomedical_Resources)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>,
    #        #<LinkedData::Models::Category:0x007f1bfeb105c8
    #        @aggregates=nil,
    #        @id=
    #            #<RDF::URI:0x3f8dff557c34(http://data.bioontology.org/categories/Other)>,
    #            @loaded_attributes=#<Set: {}>,
    #                @modified_attributes=#<Set: {}>,
    #                    @persistent=true,
    #        @previous_values=nil,
    #        @unmapped=nil>],

    if properties[:viewOf]
      # TODO: check that viewOf output is OK
      binding.pry

      print_element('viewOf', ont.viewOf)
      properties.delete(:viewOf)
      print "\n" or next if properties.empty?
    end
    if properties[:flat]
      print_element('flat', ont.flat)
      properties.delete(:flat)
      print "\n" or next if properties.empty?
    end
    if properties[:doNotUpdate]
      print_element('doNotUpdate', ont.doNotUpdate)
      properties.delete(:doNotUpdate)
      print "\n" or next if properties.empty?
    end
    if properties[:summaryOnly]
      print_element('summaryOnly', ont.summaryOnly)
      properties.delete(:summaryOnly)
      print "\n" or next if properties.empty?
    end
    #
    # don't want to inspect these goo properties
    #@aggregates=nil,
    #@persistent=true,
    #@previous_values=nil,
    #@unmapped=nil,
    #
    # summaryOnly ontologies cannot be inspected any further.
    if ont.summaryOnly
      print_element('submission', 'NONE, summaryOnly')
      print "\n" or next
    end
    # Proceed to get additional properties from the latest submission
    sub = ont.latest_submission(status: :any)
    if sub.nil?
      print_element('submission', 'ERROR')
      print "\n" or next
    end
    sub.bring_remaining
    print_element('submission', 'found #{sub.submissionId}')

    if properties[:hasOntologyLanguage]
      print_element('hasOntologyLanguage', submission_hasOntologyLanguage(sub))
      properties.delete(:hasOntologyLanguage)
      print "\n" or next if properties.empty?
    end
    if properties[:status]
      print_element('status', sub.status)
      properties.delete(:status)
      print "\n" or next if properties.empty?
    end
    if properties[:submissionStatus]
      print_element('submissionStatus', submission_status(sub))
      properties.delete(:submissionStatus)
      print "\n" or next if properties.empty?
    end
    if properties[:metrics]
      print_element('metrics', submission_metrics(sub))
      properties.delete(:metrics)
      print "\n" or next if properties.empty?
    end


    #  @authorProperty=nil,
    #  @classType=nil,
    #  @contact=
    #      [#<LinkedData::Models::Contact:0x007f7c678de088
    #          @aggregates=nil,
    #          @id=
    #              #<RDF::URI:0x3fbe33c6cccc(http://data.bioontology.org/contacts/8e2c3e30-3477-0131-b008-3d23c5e0f0ea)>,
    #              @loaded_attributes=#<Set: {}>,
    #                  @modified_attributes=#<Set: {}>,
    #                      @persistent=true,
    #          @previous_values=nil,
    #          @unmapped=nil>],
    #  @creationDate=
    #      #<DateTime: 2013-12-12T12:01:19-08:00 ((2456639j,72079s,0n),-28800s,2299161j)>,
    #      @definitionProperty=
    #          #<RDF::URI:0x3fbe33c6d58c(http://bioontology.org/ontologies/biositemap.owl#definition)>,
    #          @description=
    #              "A controlled terminology of resources, which is used to improve the sensitivity and specificity of web searches.",
    #  @diffFilePath=nil,
    #  @documentation="http://www.ncbcs.org/biositemaps/",
    #  @hasOntologyLanguage=
    #      #<LinkedData::Models::OntologyFormat:0x007f7c678df3e8
    #      @aggregates=nil,
    #  @id=
    #      #<RDF::URI:0x3fbe33c6d334(http://data.bioontology.org/ontology_formats/OWL)>,
    #      @loaded_attributes=#<Set: {}>,
    #          @modified_attributes=#<Set: {}>,
    #              @persistent=true,
    #  @hierarchyProperty=nil,
    #  @homepage="http://www.ncbcs.org/biositemaps/",
    #  @id=
    ##<RDF::URI:0x3fbe33663a9c(http://data.bioontology.org/ontologies/BRO/submissions/22)>,
    #  @masterFileName=nil,
    #      @id=
    #          #<RDF::URI:0x3fbe33c6c600(http://data.bioontology.org/ontologies/BRO/submissions/22/metrics)>,
    #      @missingImports=[],
    #          @naturalLanguage=nil,
    #      @obsoleteParent=nil,
    #      @obsoleteProperty=nil,
    #      @prefLabelProperty=
    #          #<RDF::URI:0x3fbe33c6d5dc(http://www.w3.org/2004/02/skos/core#prefLabel)>,
    #      @publication=nil,
    #      @pullLocation=nil,
    #      @released=
    #          #<DateTime: 2013-11-19T00:00:00+00:00 ((2456616j,0s,0n),+0s,2299161j)>,
    #          @status="alpha",
    #      @submissionId=22,
    #      @synonymProperty=
    #          #<RDF::URI:0x3fbe33c6d514(http://www.w3.org/2004/02/skos/core#altLabel)>,
    #      @uploadFilePath="/srv/ncbo/repository/BRO/22/BRO.owl",
    #      @uri=nil,
    #      @version="3.2.1">
























  rescue Exception => e
    puts "Failed, exception: #{e.to_json}."
  end
end

STDOUT.flush
