#!/usr/bin/env ruby

# Exit cleanly from an early interrupt
Signal.trap("INT") { exit 1 }

# Setup the bundled gems in our environment
require 'bundler/setup'

# Used for getting jobs from the queue and processing them
require_relative '../lib/ncbo_cron'
config_exists = File.exist?(File.expand_path('../../config/config.rb', __FILE__))
abort("Please create a config/config.rb file using the config/config.rb.sample as a template") unless config_exists
require_relative '../config/config'



platform = "local"
if LinkedData.settings.goo_host.include? "stage"
  platform = "stage"
elsif LinkedData.settings.goo_host.include? "prod"
  platform = "prod"
end
puts "Running on #{platform} platform; repository = #{LinkedData.settings.repository_folder}"
unless File.exists? LinkedData.settings.repository_folder
  puts "ERROR: repository path does not exist: #{LinkedData.settings.repository_folder}"
  exit!
end

require 'optparse'
OptionParser.new do |o|
  o.on('-a', '--logall', 'Log all upload file paths, annoted as correct or erroneous.') { $log_all = true }
  o.on('-n', '--dryrun', 'Only log upload file problems, do not change any data or files.') { $dry_run = true }
  o.on('-h', '--help', 'Display the help screen') { puts o; exit }
  o.parse!
end
if $dry_run
  puts 'This is a dry-run, to log upload file problems.'
end

def process_submission_upload(sub, ont)
  if sub.uploadFilePath.nil?
    # Some submissions can have a nil uploadFilePath
    sub.bring_remaining

    # UMLS ontologies do not have a valid pull location.  Set the pull location
    # to a value that will be valid, temporarily.
    # sub.hasOntologyLanguage.id.to_s.ends_with? 'UMLS'

    unless sub.valid?
      # This should not be a nil uploadFilePath, just report it, nothing can be done about it here.
      printf("ERROR:\t%-15s\tsubmission: %4d; uploadFilePath: nil\n", "#{ont.acronym}:", sub.submissionId)
      # TODO: should we delete invalid submissions?
    end
  elsif sub.uploadFilePath.start_with? "#{LinkedData.settings.repository_folder}/#{ont.acronym}/#{sub.submissionId}"
    # This could be OK
    if $log_all
      printf("VALID:\t%-15s\tsubmission: %4d; uploadFilePath: %s\n", "#{ont.acronym}:", sub.submissionId, sub.uploadFilePath)
    end
  else
    # This is an error
    printf("ERROR:\t%-15s\tsubmission: %4d; uploadFilePath: %s\n", "#{ont.acronym}:", sub.submissionId, sub.uploadFilePath)
    return if $dry_run
    # Create the new repository location, if it doesn't exist already.
    begin
      upload_file_path = "#{LinkedData.settings.repository_folder}/#{ont.acronym}/#{sub.submissionId}"
      FileUtils.mkdir_p upload_file_path
    rescue Exception => e
      puts "ERROR: failed to create submission repository directory."
      raise e
    end
    begin
      # Copy over the ontology upload file.
      upload_file_name = File.basename(sub.uploadFilePath)
      upload_file = "#{upload_file_path}/#{upload_file_name}"
      begin
        FileUtils.copy(sub.uploadFilePath, upload_file, {:preserve => true, :verbose => true} )
        sub.uploadFilePath = upload_file
      rescue Exception => e
        if e.message.start_with? 'same file:'
          # If it's the same file, it's probably a symlink and we can update the sub.uploadFilePath anyway.
          sub.uploadFilePath = upload_file
        else
          # It's some other exception, skip any change to sub.uploadFilePath, just report the failure below.
          raise e
        end
      end
      if sub.valid?
        sub.save
        # Note: The old upload file is 'orphaned' after the sub.save; this script could remove them
        # after a successful sub.save.  Instead, the files are logged so they can be removed by another process.
      else
        puts "ERROR: failed to update the triple store"
        puts sub.errors.to_json
      end
    rescue Exception => e
      puts "ERROR: failed to relocate the upload file"
      raise e
    end
    begin
      # Copy over the ontology diff file, if it exists.
      unless sub.diffFilePath.nil?
        diff_file_name = File.basename(sub.diffFilePath)
        diff_file = "#{upload_file_path}/#{diff_file_name}"
        begin
          FileUtils.copy(sub.diffFilePath, diff_file, {:preserve => true, :verbose => true} )
          sub.diffFilePath = diff_file
        rescue Exception => e
          if e.message.start_with? 'same file:'
            # If it's the same file, it's probably a symlink and we can update the sub.diffFilePath anyway.
            sub.diffFilePath = diff_file
          else
            # It's some other exception, skip any change to sub.diffFilePath, just report the failure below.
            raise e
          end
        end
      end
      if sub.valid?
        sub.save
        # Note: The old diff file is 'orphaned' after the sub.save; this script could remove them
        # after a successful sub.save.  Instead, the files are logged so they can be removed by another process.
      else
        puts "ERROR: failed to update the triple store"
        puts sub.errors.to_json
      end
    rescue Exception => e
      puts "ERROR: failed to relocate the diff file"
      raise e
    end
  end
end

#
# MAIN
#
ontologies = LinkedData::Models::Ontology.where.include(:acronym,:submissions,:summaryOnly).all
ontologies.sort! {|a,b| a.acronym.downcase <=> b.acronym.downcase }
ontologies.each do |ont|
  next if ont.summaryOnly
  ont.submissions.each do |sub|
    sub.bring(:uploadFilePath) if sub.bring?(:uploadFilePath)
    sub.bring(:diffFilePath) if sub.bring?(:diffFilePath)
    sub.bring(:pullLocation) if sub.bring?(:pullLocation)
    sub.bring(:submissionId) if sub.bring?(:submissionId)
  end
  submissions = ont.submissions.sort {|a,b| a.submissionId <=> b.submissionId }
  submissions.each do |sub|
    begin
      process_submission_upload(sub, ont)
    rescue Exception => e
      puts e.message
    end
  end
end

