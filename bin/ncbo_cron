#!/usr/bin/env ruby

# Exit cleanly from an early interrupt
Signal.trap("INT") { exit 1 }

# Setup the bundled gems in our environment
require 'bundler/setup'

# Used for getting jobs from the queue and processing them
require_relative '../lib/ncbo_cron'

# redis store for looking up queued jobs
require 'redis'

# Daemonize the process
require 'dante'

runner = Dante::Runner.new('ncbo_cron')
runner.description = "This will run a scheduled job for NCBO-related processing"

runner.with_options do |opts|
  opts.on("-P", "--pid FILE", String, "save PID in FILE when using -d option", "(default: ./bin/ncbo_cron.pid)") do |v|
    options[:pid_path] = File.expand_path(v)
  end
  opts.on("-h", "--redis-host HOST", String, "redis host (for shared locking)") do |host|
    options[:redis_host] = host
  end
  opts.on("-p", "--redis-port PORT", Integer, "redis port (for shared locking)") do |port|
    options[:redis_port] = port
  end
  opts.on("-m", "--minutes MIN", Integer, "minutes between process queue checks (override seconds)") do |m|
    options[:minutes_between] = m
  end
  opts.on("-s", "--seconds SEC", Integer, "seconds between process queue checks") do |s|
    options[:seconds_between] = s
  end
  opts.on("-c", "--pull-cron SCHED", String, "cron schedule for ontology pull") do |c|
    options[:cron_schedule] = c
  end
  opts.on("-l", "--log-level LEVEL", String, "set the log level (debug, info, error)", "(default: info)") do |c|
    options[:cron_schedule] = c
  end

  # Logging
  require 'logger'
  log_dir = File.expand_path("../../logs", __FILE__)
  FileUtils.mkdir_p(log_dir)
  options[:log_path] ||= "#{log_dir}/scheduler.log"
  
  options[:pid_path] = File.expand_path("../ncbo_cron.pid", __FILE__)
  
  # Defaults
  options[:redis_host]    ||= "localhost"
  options[:redis_port]    ||= 6379
  options[:cron_schedule] ||= "00 18 * * 1-5"
  options.delete(:host)
  options.delete(:port)
end

runner.execute do |opts|
  redis = Redis.new(host: opts[:redis_host], port: opts[:redis_port])

  puts "Running ncbo_cron with options:"
  pp opts
  
  # Redirect stdout, stderr
  log_file = File.new(opts[:log_path], "a")
  logger = Logger.new(log_file)
  $stderr = log_file
  $stdout = log_file

  options = {
    logger: logger
  }.merge(opts)

  parsing_thread = Thread.new do
    logger.debug "Setting up process queue check job"; logger.flush
    parse_options = options.dup
    parse_options.delete(:cron_schedule)
    parse_options[:job_name] = "ncbo_cron_parsing"
    NcboCron::Scheduler.scheduled_locking_job(parse_options) do
      puts "Starting ontology process queue check"
      parser = NcboCron::Models::OntologySubmissionParser.new
      parser.process_queue_submissions()
    end
  end
  
  at_exit do
    parsing_thread.kill
    parsing_thread.join
  end
  
  pull_thread = Thread.new do
    logger.debug "Setting up pull cron job"; logger.flush
    pull_options = options.dup
    pull_options.delete(:minutes_between)
    pull_options.delete(:seconds_between)
    pull_options[:job_name] = "pull_thread"
    pull_options[:scheduler_type] = :cron
    NcboCron::Scheduler.scheduled_locking_job(pull_options) do
      puts "Starting ncbo pull"
      puller = NcboCron::Models::OntologyPull.new
      puller.do_remote_ontology_pull()
    end
  end
  
  at_exit do
    pull_thread.kill
    pull_thread.join
  end
  
  parsing_thread.join
  pull_thread.join
end